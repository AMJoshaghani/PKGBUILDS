#!/bin/bash
#
# EOS update notifier for the current user.
#
# The package includes the following files:
#     eos-update-notifier           (this file)
#     eos-update-notifier.desktop   (initializes the systemd service for current user)
#     eos-update-notifier.timer     (systemd timer)
#     eos-update-notifier.service   (systemd service)
#

RET_QUIT=0
RET_UPDATE=1

DIE() {
    local msg="Error: $@"
    msg+="$(Usage)"
    echo "$msg" | Yad --width=800
    exit 1
}

WARN() {
    local msg="Warning: $@"
    msg+="$(Usage)"
    echo "$msg" | Yad --width=800
}

Yad() {
    local tool=""

    case "$1" in
        --eos_tooltype=*) tool=" ($(GetArgVal "$1"))" ; shift ;;
    esac

    /usr/bin/yad --text-info \
        --title="EndeavourOS update notifier$tool" \
        --height=300 --width=400 \
        --theme="Classic" \
        --button=yad-quit:$RET_QUIT      "$@"
}

RunCommand() {
    local sudo="$1"
    local cmd="$2"
    local toolopt="$3"

    $sudo bash -c "$cmd" | \
        Yad $toolopt --height=500 --width=700 --tail
}

Update_common() {
    local updates="$1"
    local tool="$2"
    local toolopt
    local toolcmd
    local sudo

    case "$tool" in
        pacman)
            toolcmd="pacman -Syu --noconfirm"
            toolopt="--eos_tooltype=$tool"
            sudo=pkexec
            ;;
        yay)
            toolcmd="yay -Syua --noconfirm"
            toolopt="--eos_tooltype=AUR"
            sudo=""                             # problem for non-sudoers ...
            ;;
    esac

    echo "$updates" | \
        Yad $toolopt --button=" Update $tool now!face-cool!Start $tool updater":$RET_UPDATE

    test $? -eq $RET_UPDATE && {
        RunCommand "$sudo" "$toolcmd ; printf '\n$tool done!\n'" "$toolopt"
        return 0
    }
}

GetArgVal() { echo "$1" | cut -d '=' -f 2 ; }

Main2() {
    local updates_pacman="$(checkupdates)"
    local updates_aur="$(yay -Qua)"

    if [ -z "$updates_pacman" ] && [ -z "$updates_aur" ] ; then
        test "$verbosity" = "high" && {
            # Show the nothing-to-do window.
            echo "No updates available." | \
                Yad --height=100 \
                    --timeout=$no_updates__indicator_wait_time \
                    --timeout-indicator=left &
        }
    else
        # prevent having many update sessions at the same time
        test "$EOS_UPDATER_WINDOW_ON" != "1" && {
            export EOS_UPDATER_WINDOW_ON=1
            # update pacman first!
            test -n "$updates_pacman" && { Update_common "$updates_pacman" pacman || WARN "pacman update failed." ; }
            test -n "$updates_aur"    && { Update_common "$updates_aur"    yay    || WARN "AUR update failed." ; }
            export EOS_UPDATER_WINDOW_ON=0
        }
    fi
}

Usage() {
    local iwt="$initial_waittime"
    test -z "$iwt" && iwt="[none]"

    local prog_name="$(basename $0)"

    cat <<EOF


Usage: $prog_name [options]

Options:
   -init       Initialize $prog_name systemd service for current user.
   -iw=X       Initial sleep time. Value syntax from 'sleep' program.
               Default: $iwt.
   -mode=X     Operation mode (onetimer or loop).
               Note that the loop mode is not designed for systemd.
               Default: $mode.
   -lwt=X      Loop wait time (only in loop mode). X value is like in 'sleep'.
               Default: $loop_waittime.
   -nw=X       Max time (seconds) to show the "No updates available" window.
               Default: $no_updates__indicator_wait_time.
   -q          Be quieter with dialogs.
EOF
}

Main()
{
    local initial_waittime="5s"
    local loop_waittime=60m
    local no_updates__indicator_wait_time=10
    local verbosity=high
    local mode=onetimer  # "onetimer" or "loop"
    local systemd=0
    local arg

    for arg in "$@" ; do
        case "$arg" in
            -init)
                local progname=eos-update-notifier
                local configdir="$HOME/.config/systemd/user"
                local url=https://github.com/endeavouros-team/PKGBUILDS/raw/master/$progname
                mkdir -p "$configdir"
                if [ ! -r "$configdir"/$progname.service ] || [ ! -r "$configdir"/$progname.timer ]
                then
                    wget -q -O "$configdir"/$progname.service $url/$progname.service
                    wget -q -O "$configdir"/$progname.timer   $url/$progname.timer
                    systemctl --user enable $progname.timer
                    systemctl --user start  $progname.timer
                fi
                echo "$progname service initialized." >&2
                return
                ;;
            -iw=*)
                initial_waittime="$(GetArgVal "$arg")"
                ;;
            -lwt=*)
                loop_waittime="$(GetArgVal "$arg")"
                ;;
            -nw=*)
                no_updates__indicator_wait_time="$(GetArgVal "$arg")"
                ;;
            -q)
                verbosity=low
                ;;
            -systemd)
                systemd=1
                ;;
            -mode=*)
                mode="$(GetArgVal "$arg")"
                case "$mode" in
                    onetimer | loop) ;;
                    *) DIE "Warning: unsupported mode '$mode'." ; break ;;
                esac
                ;;
            -*)
                DIE "unsupported option '$arg'."
                ;;
            *)
                DIE "unsupported parameter '$arg'."
                ;;
        esac
    done
    if [ $systemd -eq 1 ] ; then
        # make sure to have proper options when systemd called
        verbosity=low
        mode=onetimer
    fi

    test -n "$initial_waittime" && sleep "$initial_waittime"

    while true ; do
        Main2
        test "$mode" = "onetimer" && break
        sleep "$loop_waittime"
    done
}

Main "$@"
