#!/bin/bash
#
# EOS update notifier for the current user.
#
# The package includes the following files:
#     eos-update-notifier           (this file)
#     eos-update-notifier.desktop   (initializes the systemd service for current user)
#     eos-update-notifier.timer     (systemd timer)
#     eos-update-notifier.service   (systemd service)
#

#######################################################################
EOS_SCRIPTS_YAD=/usr/share/endeavouros/scripts/eos-script-lib-yad
test -r  $EOS_SCRIPTS_YAD || {
    echo "ERROR: cannot find $EOS_SCRIPTS_YAD" >&2
    exit 1
}
source $EOS_SCRIPTS_YAD
unset EOS_SCRIPTS_YAD

export -f eos_yad_terminal
export -f eos_yad_check_internet_connection
export -f eos_yad_GetArgVal
export -f eos_yad_RunCmdTermBash
export -f eos_yad_problem
export -f eos_yad_DIE
export -f eos_yad_WARN
#######################################################################

echo2() { echo "$@" >&2 ; }
debug() {
    local DEBUG=1
    test "$verbosity" = "low" && DEBUG=0
    test $DEBUG -eq 1 && echo2 "$@"
}

Yad() {
    # NOTE: normal button return value is 0.
    # If user wants other button return values, they MUST be != 0 !!!

    local title

    case "$1" in
        --*) title="EndeavourOS update notifier" ;;
        *) title="$1" ; shift ;;
    esac

    /usr/bin/yad --text-info \
        --title="$title" \
        --height=300 --width=400 \
        --theme="Classic" --tail \
        --button=yad-quit:0             "$@"
}

Update_common() {
    local updates="$1"
    local source="$2"
    local toolcmd

    case "$source" in
        upstream) toolcmd="pkexec pacman -Syu" ;;
        AUR)      toolcmd="yay -Syua" ;;                             # problem for non-sudoers ...
    esac

    echo "$updates" | \
        Yad "Updates are available from $source" \
            --button=" Update software from $source!face-cool!Start $source updater":1  # note: button value must be != 0

    test $? -eq 1 && {
        eos_yad_RunCmdTermBash "echo Updating from $source... ; $toolcmd && printf '\n$source update done!\n'"
        return 0
    }
}

CheckArchNews() {
    local conf=/etc/eos-update-notifier.conf
    local CheckArchNewsForYou=yes

    test -r $conf && source $conf

    if [ "$CheckArchNewsForYou" = "yes" ] ; then
        test "$newsdays" -gt 0 && {
            if [ "$verbosity" = "high" ] ; then
                arch-news-for-you $newsdays
            else
                arch-news-for-you $newsdays 2>/dev/null
            fi
        }
    fi
}

Main2() {
    local CheckAurUpdates=yes
    local updates_pacman=""
    local updates_aur=""

    CheckArchNews

    test "$EOS_UPDATER_WINDOW_ON" != "1" && {
        export EOS_UPDATER_WINDOW_ON=1        # prevent having many update sessions at the same time

        # update pacman first!

        updates_pacman="$(checkupdates)"
        if [ -n "$updates_pacman" ] ; then
            Update_common "$updates_pacman" upstream || eos_yad_WARN "upstream update failed."
        else
            debug "No upstream updates."
        fi

        test "$CheckAurUpdates" = "yes" && updates_aur="$(yay -Qua)"
        if [ -n "$updates_aur" ] ; then
            Update_common "$updates_aur" upstream || eos_yad_WARN "AUR update failed."
        else
            debug "No AUR updates."
        fi

        export EOS_UPDATER_WINDOW_ON=0
    } || {
        debug "Sorry, another process is currently checking for updates."
    }

    if [ -z "$updates_pacman" ] && [ -z "$updates_aur" ] ; then
        test "$verbosity" = "high" && {
            # Show the nothing-to-do window.
            echo "No updates available." | \
                Yad --height=100 \
                    --timeout=$no_updates__indicator_wait_time \
                    --timeout-indicator=left &
        }
    fi
}

FetchAndCheck() {
    local configdir="$1"
    local progname="$2"
    local url="$3"
    local sha512sums xx

    pushd "$configdir" >/dev/null

    wget -q -O $progname.service.pacnew $url/$progname.service || eos_yad_DIE "$FUNCNAME: wget 'service' failed."
    wget -q -O $progname.timer.pacnew   $url/$progname.timer   || eos_yad_DIE "$FUNCNAME: wget 'timer' failed."

    # Note: this way of checking assumes PKGBUILD has certain order in 'source' and 'sha52sums'.
    wget -q --timeout=10 $url/PKGBUILD || \
        eos_yad_DIE "$FUNCNAME: wget 'PKGBUILD' failed."
    readarray -t sha512sums <<< $(grep -A5 "^sha512sums=" PKGBUILD | tail -n 2 | tr -d "'" | tr -d ')')
    rm -f PKGBUILD
    echo "${sha512sums[0]}  $progname.timer.pacnew"   | sha512sum -c || \
        eos_yad_DIE "$FUNCNAME: checksum failed for the new $progname.timer"
    echo "${sha512sums[1]}  $progname.service.pacnew" | sha512sum -c || \
        eos_yad_DIE "$FUNCNAME: checksum failed for the new $progname.service"

    for xx in timer service ; do
        rm -f $progname.$xx.bak
        test -r $progname.$xx && mv $progname.$xx $progname.$xx.bak
        mv $progname.$xx.pacnew $progname.$xx
    done

    popd >/dev/null
}

CheckInternetConnection() {
    local wait_rounds="$1"
    local one_wait="$2"

    test -z "$wait_rounds" && wait_rounds=8
    test -z "$one_wait"    && one_wait=5s

    # Wait for internet connection max "$wait_rounds * $one_wait" seconds.

    eos_yad_check_internet_connection no_fail_dialog $wait_rounds $one_wait || {
        if [ "$verbosity" = "high" ] ; then
            echo "Internet connection is not available!" | \
                eos_yad_problem "Error from eos-update-notifier" --width=400 --height=200 &
        fi
        debug "Error: eos-update-notifier: internet connection is not available!"
        return 1
    }
}

Initialize() {    # initialize service and timer for the current user

    local configdir="$HOME/.config/systemd/user"
    local url=https://github.com/endeavouros-team/PKGBUILDS/raw/master/$progname

    mkdir -p "$configdir"

    if [ ! -r "$configdir"/$progname.service ] || [ ! -r "$configdir"/$progname.timer ] || [ "$arg" = "-init-force" ]
    then
        # -init-force may bring updated .service and .timer files
        if [ "$arg" = "-init-force" ] ; then
            systemctl --user status $progname.timer >/dev/null && {
                systemctl --user stop    $progname.timer
                systemctl --user disable $progname.timer
            }
        fi
        FetchAndCheck "$configdir" "$progname" "$url"
        systemctl --user enable $progname.timer
        systemctl --user start  $progname.timer
        debug "New '$configdir/$progname.service' successfully set up."
        debug "New '$configdir/$progname.timer' successfully set up."
        debug "$progname service initialized for user '$(basename "$HOME")'."
    fi
}

Usage() {
    local iwt="$initial_waittime"
    test -z "$iwt" && iwt="[none]"

    local prog_name="$progname"
    test -z "$prog_name" && prog_name="$(basename $0) [basename]"

    cat <<EOF


Usage: $prog_name [options]

Options:
   -init        Initialize $prog_name systemd service for current user.
   -init-force  Same as -init, but may overwrite existing user service files.
   -iw=X        Initial sleep time. Value syntax from 'sleep' program.
                Default: $iwt.
   -mode=X      Operation mode (onetimer or loop).
                Note that the loop mode is not designed for systemd.
                Default: $mode.
   -lwt=X       Loop wait time (only in loop mode). X value is like in 'sleep'.
                Default: $loop_waittime.
   -nw=X        Max time (seconds) to show the "No updates available" window.
                Default: $no_updates__indicator_wait_time.
   -news=X      Show the 'Arch latest news for you' within the last X days.
                If X is 0, then no news are displayed.
                Default: X is $newsdays.
   -q           Be quieter with dialogs.
EOF
}

InitialWait() {
    test -n "$initial_waittime" && {
        debug -n "Initial wait for $initial_waittime ... " >&2
        sleep "$initial_waittime"
        debug "done." >&2
    }
}

Main()
{
    local initial_waittime="5s"  # was 10s
    local loop_waittime=60m
    local no_updates__indicator_wait_time=10
    local verbosity=high
    local mode=onetimer  # "onetimer" or "loop"
    local systemd=0
    local newsdays=30
    local arg
    local progname=eos-update-notifier
    local initialize=""

    for arg in "$@" ; do
        case "$arg" in
            -init | -init-force)
                initialize="$arg"
                ;;
            -iw=*)
                initial_waittime="$(eos_yad_GetArgVal "$arg")"
                ;;
            -lwt=*)
                loop_waittime="$(eos_yad_GetArgVal "$arg")"
                ;;
            -nw=*)
                no_updates__indicator_wait_time="$(eos_yad_GetArgVal "$arg")"
                ;;
            -news=*)
                newsdays="$(eos_yad_GetArgVal "$arg")"
                ;;
            -q)
                verbosity=low
                ;;
            -systemd)
                systemd=1
                ;;
            -mode=*)
                mode="$(eos_yad_GetArgVal "$arg")"
                case "$mode" in
                    onetimer | loop) ;;
                    *) eos_yad_DIE "Unsupported mode '$mode'." ; break ;;
                esac
                ;;
            -*)
                eos_yad_DIE "Unsupported option '$arg'."
                ;;
            *)
                eos_yad_DIE "Unsupported parameter '$arg'."
                ;;
        esac
    done
    if [ $systemd -eq 1 ] ; then
        # make sure to have proper options when systemd called
        verbosity=low
        mode=onetimer
    fi

    test "$initialize" != "-init-force" && InitialWait

    # Now internet connection is required.
    CheckInternetConnection || return 1

    case "$initialize" in
        -init-force | -init) Initialize ; return ;;
    esac

    while true ; do
        Main2
        test "$mode" = "onetimer" && break
        sleep "$loop_waittime"
    done
}

Main "$@"
